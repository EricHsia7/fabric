{"version":3,"file":"252.c266351eb74452222323.min.js","mappings":"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","sources":["webpack://fabric/./node_modules/stacktrace-gps/node_modules/source-map/lib/source-node.js","webpack://fabric/./node_modules/stacktrace-gps/node_modules/source-map/lib/util.js","webpack://fabric/./node_modules/stacktrace-gps/node_modules/source-map/source-map.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are removed from this array, by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var shiftNextLine = function() {\n      var lineContents = remainingLines.shift();\n      // The last line of a file might not have a newline.\n      var newLine = remainingLines.shift() || \"\";\n      return lineContents + newLine;\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[0];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[0];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLines.length > 0) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n"],"names":["SourceMapGenerator","util","REGEX_NEWLINE","isSourceNode","SourceNode","aLine","aColumn","aSource","aChunks","aName","this","children","sourceContents","line","column","source","name","add","fromStringWithSourceMap","aGeneratedCode","aSourceMapConsumer","aRelativePath","node","remainingLines","split","shiftNextLine","shift","lastGeneratedLine","lastGeneratedColumn","lastMapping","eachMapping","mapping","generatedLine","code","nextLine","substr","generatedColumn","addMappingWithCode","length","join","sources","forEach","sourceFile","content","sourceContentFor","setSourceContent","undefined","originalLine","originalColumn","prototype","aChunk","Array","isArray","chunk","TypeError","push","prepend","i","unshift","walk","aFn","len","aSep","newChildren","replaceRight","aPattern","aReplacement","lastChild","replace","aSourceFile","aSourceContent","toSetString","walkSourceContents","Object","keys","fromSetString","toString","str","toStringWithSourceMap","aArgs","generated","map","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","original","addMapping","idx","charCodeAt","sourceContent","exports","getArg","aDefaultValue","arguments","Error","urlRegexp","dataUrlRegexp","urlParse","aUrl","match","scheme","auth","host","port","path","urlGenerate","aParsedUrl","url","normalize","aPath","part","isAbsolute","parts","up","splice","aRoot","aPathUrl","aRootUrl","joined","charAt","relative","level","indexOf","index","lastIndexOf","slice","supportsNullProto","create","identity","s","isProtoString","strcmp","aStr1","aStr2","aStr","compareByOriginalPositions","mappingA","mappingB","onlyCompareOriginal","cmp","compareByGeneratedPositionsDeflated","onlyCompareGenerated","compareByGeneratedPositionsInflated","SourceMapConsumer"],"sourceRoot":""}