<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Whiteboard</title>
  <style>
    * {
      -webkit-appearance: none;
      outline: none;
      -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    }

    body {
      background: var(--d-canvas-bg);
    }

    svg#canvas,
    canvas#canvas_p {
      position: fixed;
      top: 0px;
      left: 0px;
      width: 100%;
      height: 100%;
      user-select: none;
      -webkit-user-select: none;
    }

    .tools {
      position: fixed;
      top: 15px;
      left: 15px;
      width: clamp(120px, 90%, 180px);
      height: 40px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 13px;
      background: rgba(26, 26, 26, 0.6);
      display: flex;

    }

    .f {
      position: fixed;
      top: 0px;
      left: 0px;
      width: 10px;
      height: 2px;
      transform-origin: top left;
      background: #ff0000;
    }

    button {
      -webkit-appearance: none;
      appearance: none;
      border: none;
      margin: 0px;
      padding: 0px;
      box-sizing: border-box;
      background: transparent;
      display: block;
      border-radius: 0px;
      font-size: unset;
      font-weight: unset;

    }

    .tools button svg {
      width: 30px;
      height: 30px;
      opacity: 0.6;
      transition: opacity 0.35s;
    }

    .tools button[s="1"] svg {
      opacity: 1;
    }

    .tools button {
      width: 33%;
      height: 40;
      display: flex;
      justify-content: center;
      align-items: center;
    }
  </style>
</head>

<body>
  <svg width="100" height="100" id="canvas">
    <g id="bg"></g>
    <g id="pen"></g>
  </svg>
  <canvas id="canvas_p"></canvas>
  <div id="info"></div>
  <button onclick="rubber=false;" class="pen">pen</button>
  <button onclick="rubber=true;" class="rubber">rubber</button>
</body>
<script>
  new VConsole();
  Math.ol = function (p) {
    if (Math.abs(parseInt(p) - p) > 0) {
      return parseFloat(parseFloat(p).toFixed(3))
    }
    return p
  }


  var keys = { 37: 1, 38: 1, 39: 1, 40: 1 };

  function preventDefault(e) {
    e.preventDefault();
  }

  function preventDefaultForScrollKeys(e) {
    if (keys[e.keyCode]) {
      preventDefault(e);
      return false;
    }
  }

  // modern Chrome requires { passive: false } when adding event
  var supportsPassive = false;
  try {
    window.addEventListener(
      "test",
      null,
      Object.defineProperty({}, "passive", {
        get: function () {
          supportsPassive = true;
        }
      })
    );
  } catch (e) { }

  var wheelOpt = supportsPassive ? { passive: false } : false;
  var wheelEvent =
    "onwheel" in document.createElement("div") ? "wheel" : "mousewheel";

  // call this to Disable
  function disableScroll() {
    window.addEventListener("DOMMouseScroll", preventDefault, false); // older FF
    window.addEventListener(wheelEvent, preventDefault, wheelOpt); // modern desktop
    window.addEventListener("touchmove", preventDefault, wheelOpt); // mobile
    window.addEventListener("keydown", preventDefaultForScrollKeys, false);
  }
  // call this to Enable
  function enableScroll() {
    window.removeEventListener("DOMMouseScroll", preventDefault, false);
    window.removeEventListener(wheelEvent, preventDefault, wheelOpt);
    window.removeEventListener("touchmove", preventDefault, wheelOpt);
    window.removeEventListener("keydown", preventDefaultForScrollKeys, false);
  }
  disableScroll();
  var svg_canvas = document.querySelector("svg#canvas");
  var canvas = document.querySelector("canvas#canvas_p");
  var canvas_ctx = canvas.getContext('2d');

  var svg_canvas_p = document.querySelector("svg#canvas g#pen");
  svg_canvas.setAttributeNS(null, "width", window.innerWidth + "px");
  svg_canvas.setAttributeNS(null, "height", window.innerHeight + "px");
  svg_canvas.setAttributeNS(
    null,
    "viewbox",
    `0,0,${window.innerWidth},${window.innerHeight}`
  );
  var dpr = window.devicePixelRatio
  canvas.setAttributeNS(null, "width", window.innerWidth * dpr + "px");
  canvas.setAttributeNS(null, "height", window.innerHeight * dpr + "px");
  var doc = document.documentElement;
  var x = 0;
  var y = 0;
  var current_pen_color = "var(--d-pen-000000-color)";
  var pen_width_base = 1.7
  var current_pen_width = 1.5
  var block_size = 10
  var current_pen_color_snapshot = getComputedStyle(doc).getPropertyValue('--d-pen-000000-color')
  var pendown = false;
  var penPoints = [];
  var penPoints_a = []
  var penPoints_b = []
  var svg_canvas_history = [];
  var speed_log = []
  var svg_canvas_points = {};
  var current_path_points = {};
  var current_path_id = "";
  var current_point_id = "";
  var current_path_points_offset = 0
  var rubber = false;
  var pen_type = 1 //0:ball_pen,1:fountain_pen
  var force = 0
  var wq = 0
  var lk = false
  var speed = 0
  var canvas_id = gid('canvas')
  var rubber_symbol = document.querySelector('#rubber circle')

  var path_main, path_a, path_b
  function gid(n) {
    var genidchars =
      "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQURSTUVWXYZ";
    var genid = "";
    for (var i = 0; i < 16; i++) {
      var genrandomNumber = Math.floor(Math.random() * genidchars.length);
      genid += genidchars.substring(genrandomNumber, genrandomNumber + 1);
    }
    if (!(n === undefined)) {
      n = n.replaceAll("-", "_");
      return n + "_" + genid;
    }
    return "id_" + genid;
  }

  function getMid(x1, y1, x2, y2) {
    return { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
  }
  function calcPoints(arr) {
    if (arr.length < 5) {
      return arr;
    }

    return res;
  }
  function drawBlocks(w, h) {
    var block = function (x, y) {
      return `<g transform="translate(${x} ${y})"><path d="M5 8.88178e-16L5 20L5 8.88178e-16Z" fill="none" opacity="1" stroke="var(--d-block-f5f5f5-color)" stroke-linecap="butt" stroke-linejoin="miter" stroke-width="0.45"/><path d="M15 8.88178e-16L15 20L15 8.88178e-16Z" fill="none" opacity="1" stroke="var(--d-block-f5f5f5-color)" stroke-linecap="butt" stroke-linejoin="miter" stroke-width="0.45"/><path d="M0 5L20 5L0 5Z" fill="none" opacity="1" stroke="var(--d-block-f5f5f5-color)" stroke-linecap="butt" stroke-linejoin="miter" stroke-width="0.45"/><path d="M0 15L20 15L0 15Z" fill="none" opacity="1" stroke="var(--d-block-f5f5f5-color)" stroke-linecap="butt" stroke-linejoin="miter" stroke-width="0.45"/></g>`;
    };
    var j = [];
    var wc = Math.floor(w / block_size) + 1;
    var hc = Math.floor(h / block_size) + 1;
    for (var m = 0; m < hc; m++) {
      for (var n = 0; n < wc; n++) {
        j.push(block(n * block_size, m * block_size));
      }
    }

    document.querySelector("#bg").innerHTML = `<rect x="0" y="0" width="${w}" height="${h}" fill="var(--d-canvas-bg)"/>${j.join("")}`;
  }

  function getBlock(x, y) {
    var wc = Math.abs(Math.floor(x / block_size) + 1);
    var hc = Math.abs(Math.floor(y / block_size) + 1);
    return [wc, hc];
  }
  function drawPoint(x, y, s) {
    var p = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    p.setAttributeNS(null, "id", s);
    p.setAttributeNS(null, "cx", x);
    p.setAttributeNS(null, "cy", y);
    p.setAttributeNS(null, "r", 1);
    p.setAttributeNS(null, "fill", current_pen_color);
    svg_canvas_p.appendChild(p);
  }
  function segmentsToPath(segments) {
    var pathCommand = `M${segments[0].x},${segments[0].y}`;
    for (var i = 1; i < segments.length - 1; i++) {
      var c = segments[i];
      var n = segments[i + 1] || c;

      pathCommand += `Q${c.x},${c.y},${(c.x + n.x) / 2},${(c.y + n.y) / 2}`;
    }
    return pathCommand;
  }
  function pathToOriginalSegments(path) {
    var all_q = path.match(/Q[0-9\.]{1,},[0-9\.]{1,},[0-9\.]{1,},[0-9\.]{1,}/gm);
    var o = [];
    var j = all_q.length;
    for (var w = 0; w < j; w++) {
      var k = all_q[w].substring(1).split(",");
      o.push({ x: Math.ol(k[0]), y: Math.ol(k[1]) });
    }
    return o;
  }

  function pathToSegments(m, d) {
    if (m === 0) {
      var p = document.querySelector("#" + d);
    }
    var points = [];
    var totalLength = p.getTotalLength();
    for (let i = 0; i < totalLength; i += 1) {
      var { x, y } = p.getPointAtLength(i);
      points.push({ x: Math.ol(x), y: Math.ol(y) });
    }
    return points;
  }

  function simplifyPath(points, tolerance) {
    if (points.length < 3) {
      return points;
    }

    var dmax = 0;
    var index = 0;

    // Find the point with the maximum distance
    for (var i = 1; i < points.length - 1; i++) {
      var d = distanceToSegment(points[i], points[0], points[points.length - 1]);
      if (d > dmax) {
        index = i;
        dmax = d;
      }
    }

    // If max distance is greater than tolerance, split the curve
    if (dmax > tolerance) {
      var leftPoints = points.slice(0, index + 1);
      var rightPoints = points.slice(index);
      var simplifiedLeft = simplifyPath(leftPoints, tolerance);
      var simplifiedRight = simplifyPath(rightPoints, tolerance);
      return simplifiedLeft
        .slice(0, simplifiedLeft.length - 1)
        .concat(simplifiedRight);
    } else {
      return [points[0], points[points.length - 1]];
    }
  }

  function distanceToSegment(point, start, end) {
    var dx = end.x - start.x
    var dy = end.y - start.y
    var d = dx * dx + dy * dy;
    var t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / d;

    if (t < 0) {
      dx = point.x - start.x;
      dy = point.y - start.y;
    } else if (t > 1) {
      dx = point.x - end.x;
      dy = point.y - end.y;
    } else {
      var closestPoint = { x: start.x + t * dx, y: start.y + t * dy };
      dx = point.x - closestPoint.x;
      dy = point.y - closestPoint.y;
    }

    return Math.sqrt(dx * dx + dy * dy)
  }

  function drawPath(d, w) {
    var p = document.createElementNS("http://www.w3.org/2000/svg", "path");
    p.setAttributeNS(null, "d", d);
    p.setAttributeNS(null, "stroke-width", pen_width_base);
    p.setAttributeNS(null, "stroke", current_pen_color);
    p.setAttributeNS(null, "fill", "none");
    p.setAttributeNS(null, "stroke-linecap", "round");
    p.setAttributeNS(null, "fill-rule", "nonzero");
    p.setAttributeNS(null, "id", w);
    svg_canvas_p.appendChild(p);
  }

  function updatePath(d, s, m) {
    var p = document.querySelector("#" + s);
    if (!(p === null)) {
      p.setAttribute("d", d);
      if (m === 1) {
        p.setAttributeNS(null, "stroke-width", 0);
        p.setAttributeNS(null, "fill", current_pen_color);
        p.setAttributeNS(null, "stroke", "none");
      }
    }

  }
  function releaseElement(s) {
    var p = document.querySelector("#" + s);
    if (!(p === null)) {
      p.removeAttribute("id");
    }
  }
  function removeElement(s) {
    var p = document.querySelector("#" + s);
    if (!(p === null)) {
      p.remove();
    } else {
      return true;
    }
  }
  function removeElements(s) {
    var s = document.querySelectorAll(s);
    if (!(s === null)) {
      var j = s.length;
      for (var r = 0; r < j; r++) {
        var p = s[r];
        if (!(p === null)) {
          p.remove();
        }
      }
    }
  }
  drawBlocks(window.innerWidth, window.innerHeight);

  canvas.addEventListener("touchstart", function (e) {
    x = e.targetTouches[0].pageX - doc.scrollLeft;
    y = e.targetTouches[0].pageY - doc.scrollTop;
    penPoints = [];
    penPoints_a = []
    penPoints_b = []
    speed_log = []
    current_path_id = gid("path");
    current_point_id = gid("point");
    force = 0
    wq = 0
    lk = false
    speed = 0
    current_path_points = {}
    current_pen_width = pen_width_base * 1
    current_pen_color_snapshot = getComputedStyle(doc).getPropertyValue('--d-pen-000000-color')

    if (!rubber) {
      pendown = true;
      drawPath("", current_path_id);
      drawPoint(x, y, current_point_id);
      penPoints.push({ x: x, y: y });
      path_main = new Path2D()
      path_a = new Path2D()
      path_b = new Path2D()

      path_main.moveTo(x * dpr, y * dpr);
      path_a.moveTo(x * dpr, y * dpr);
      path_b.moveTo(x * dpr, y * dpr);
    }
    else {
      rubber_symbol.setAttribute('transform', `translate(${x} ${y})`)
      rubber_symbol.setAttribute('opacity', '1')
    }
    current_path_points_offset = 0
  });
  canvas.addEventListener("touchmove", function (e) {
    x = e.targetTouches[0].pageX - doc.scrollLeft;
    y = e.targetTouches[0].pageY - doc.scrollTop;

    if (e.targetTouches[0].force) {
      force = e.targetTouches[0].force
    }
    if (penPoints.length > 5) {
      var last_p = penPoints.slice(penPoints.length - 5, penPoints.length - 1)
      var last_x = []
      var last_y = []
      for (var t = 0; t < last_p.length; t++) {
        last_x.push(last_p[t].x)
        last_y.push(last_p[t].y)
      }
      var lp = getLine(last_x, last_y)
      wq = -1 / lp.a

      if (lp.sx < lp.sy) {
        lk = true
      }
    }


    var op = getBlock(x, y);
    if (pendown) {
      var current_time = new Date().getTime()
      var a1 = 180 + Math.atan(wq) * 180 / Math.PI
      var a2 = a1 + 180

      if (isNaN(a1)) {
        if (lk) {
          a1 = 180
          a2 = 360
        }
        else {
          a1 = 90
          a2 = 270
        }
      }

      penPoints.push({ x: x, y: y, force: force, angle: a1, time_stamp: current_time });
      if (penPoints.length > 2) {
        path_main = new Path2D()

        var pervious_point = penPoints[penPoints.length - 2]
        path_main.moveTo(pervious_point.x * dpr, pervious_point.y * dpr);
        if (penPoints_a.length > 3) {
          path_a = new Path2D()
          path_b = new Path2D()
          var pervious_point_a = penPoints_a[penPoints_a.length - 1]
          var pervious_point_b = penPoints_b[penPoints_b.length - 1]

          path_a.moveTo(pervious_point_a.sx, pervious_point_a.sy);
          path_b.moveTo(pervious_point_b.sx, pervious_point_b.sy);
        }

        var pervious_point = penPoints[penPoints.length - 2]
        s = Math.sqrt(Math.pow(pervious_point.x - x, 2) + Math.pow(pervious_point.y - y, 2)) / (current_time - pervious_point.time_stamp)
        speed = s
        if (speed < 0) {
          speed = 0
        }
        if (speed > 3) {
          speed = 3
        }
        speed_log.push(s)
      }

      current_pen_width = Math.min(Math.max(Math.min(Math.max(pen_width_base * 0.75 + pen_width_base * (1 / (speed)) * 0.25, pen_width_base), pen_width_base * (1 + 0.35)), current_pen_width - (0.01)), current_pen_width + (0.1))


      canvas_ctx.lineWidth = current_pen_width * dpr
      canvas_ctx.strokeStyle = current_pen_color_snapshot;
      path_main.lineTo(x * dpr, y * dpr);
      canvas_ctx.stroke(path_main);
      var radius = current_pen_width
      if (pen_type === 1) {
        radius *= (1 + force / 0.25) / 2
      }
      radius = Math.min(radius - 0.01, current_pen_width)

      var cx1 = x + radius * Math.cos(2 * Math.PI * a1 / 360)
      var cy1 = y + radius * Math.sin(2 * Math.PI * a1 / 360)
      var cx2 = x + radius * Math.cos(2 * Math.PI * a2 / 360)
      var cy2 = y + radius * Math.sin(2 * Math.PI * a2 / 360)

      var radius_a = (radius - current_pen_width / 2) * dpr
      canvas_ctx.lineWidth = current_pen_width * dpr

      var s_cx1 = x * dpr + radius_a * Math.cos(2 * Math.PI * a1 / 360)
      var s_cy1 = y * dpr + radius_a * Math.sin(2 * Math.PI * a1 / 360)
      var s_cx2 = x * dpr + radius_a * Math.cos(2 * Math.PI * a2 / 360)
      var s_cy2 = y * dpr + radius_a * Math.sin(2 * Math.PI * a2 / 360)

      if (pen_type === 1) {


        penPoints_a.push({ x: Math.ol(cx1), y: Math.ol(cy1), sx: (s_cx1), sy: (s_cy1) })
        penPoints_b.push({ x: Math.ol(cx2), y: Math.ol(cy2), sx: (s_cx2), sy: (s_cy2) })
        path_a.lineTo(s_cx1, s_cy1);
        canvas_ctx.stroke(path_a);
        canvas_ctx.closePath(path_a);
        path_b.lineTo(s_cx2, s_cy2);
        canvas_ctx.stroke(path_b);
        canvas_ctx.closePath(path_b);

      }
    }

    if (rubber) {
      rubber_symbol.setAttribute('transform', `translate(${x} ${y})`)
      if (svg_canvas_points.hasOwnProperty("w_" + op[0])) {
        if (svg_canvas_points["w_" + op[0]].hasOwnProperty("h_" + op[1])) {
          if (svg_canvas_points["w_" + op[0]]["h_" + op[1]].hasOwnProperty(current_path_id)) {

          }
          var all_id = svg_canvas_points["w_" + op[0]]["h_" + op[1]];

          var all_id_len = all_id.length

          for (var e in all_id) {
            var oo = removeElement(e);
            var oo = removeElement(`${e}_main`);
            delete svg_canvas_points["w_" + op[0]]["h_" + op[1]][e];
          }
        }
      }
    }
  });
  canvas.addEventListener("touchend", function (e) {
    if (pendown) {
      pendown = false;
      var doc = document.documentElement;
      penPoints.push({ x: x, y: y });
      var register_id = current_path_id
      if (penPoints.length > 3) {
        var w = Math.ol(penPoints.length / 50);
        if (w < 0.5) {
          w = 0;
        } else {
          if (w > 1) {
            w = 1;
          }
        }
        if (pen_type === 1) {
          updatePath(segmentsToPath([penPoints[0]].concat(simplifyPath(penPoints_a, w * 1.6).concat(simplifyPath(penPoints_b.reverse(), w * 1.6)))), current_path_id, 1)
          drawPath(segmentsToPath(simplifyPath(penPoints, w)), `${current_path_id}_main`, 1);
        }
        else {
          updatePath(segmentsToPath(simplifyPath(penPoints, w)), `${current_path_id}`, 0);
        }
        // releaseElement(current_path_id)
        removeElement(current_point_id);
        var pathSeg = pathToSegments(0, `${current_path_id}`);
      } else {
        var pathSeg = penPoints
        register_id = current_point_id
        //releaseElement(current_point_id)
      }

      for (var q = 0; q < pathSeg.length; q++) {
        var op = getBlock(pathSeg[q].x, pathSeg[q].y);
        if (!svg_canvas_points.hasOwnProperty("w_" + op[0])) {
          svg_canvas_points["w_" + op[0]] = {};
        }
        if (svg_canvas_points.hasOwnProperty("w_" + op[0])) {
          if (!svg_canvas_points["w_" + op[0]].hasOwnProperty("h_" + op[1])) {
            svg_canvas_points["w_" + op[0]]["h_" + op[1]] = {};
          }
        }

        if (svg_canvas_points.hasOwnProperty("w_" + op[0])) {
          if (svg_canvas_points["w_" + op[0]].hasOwnProperty("h_" + op[1])) {
            if (
              !svg_canvas_points["w_" + op[0]]["h_" + op[1]].hasOwnProperty(
                register_id
              )
            ) {
              svg_canvas_points["w_" + op[0]]["h_" + op[1]][
                register_id
              ] = 1;
            }
          }
        }
      }
      canvas_ctx.closePath();
      canvas_ctx.clearRect(0, 0, window.innerWidth * dpr, window.innerHeight * dpr);
      svg_canvas_history.push(svg_canvas_p.innerHTML);
    }
    if (rubber) {
      rubber_symbol.setAttribute('opacity', '0')
    }
    localStorage.setItem(canvas_id, svg_canvas_history[svg_canvas_history.length - 1].replaceAll(/id="(path|circle)_[A-Za-z0-9]{16,16}"/gm, ''))
  });

  window.addEventListener("resize", (event) => {
    svg_canvas.setAttributeNS(null, "width", window.innerWidth + "px");
    svg_canvas.setAttributeNS(null, "height", window.innerHeight + "px");
    svg_canvas.setAttributeNS(
      null,
      "viewbox",
      `0,0,${window.innerWidth},${window.innerHeight}`
    );
    canvas.setAttributeNS(null, "width", window.innerWidth * dpr + "px");
    canvas.setAttributeNS(null, "height", window.innerHeight * dpr + "px");
    drawBlocks(window.innerWidth, window.innerHeight);
  });


  function getLine(x, y) {
    var x_avg = getAvgerage(x)
    var y_avg = getAvgerage(y)
    var s_xx = getSi2(x, x_avg)
    var s_yy = getSi2(y, y_avg)
    var s_xy = getSi3(x, y, x_avg, y_avg)
    var sigma_x = Math.sqrt(s_xx / x.length)
    var sigma_y = Math.sqrt(s_yy / y.length)
    var r = s_xy / (Math.sqrt(s_xx * s_yy))
    var line_a = r * sigma_y / sigma_x
    var line_b = (y_avg) - line_a * (x_avg)
    return { a: line_a, b: line_b, sx: sigma_x, sy: sigma_y }
  }
  function getSum(arr) {
    var initialValue = 0
    var sum = arr.reduce(
      (accumulator, currentValue) => accumulator + currentValue,
      initialValue
    );
    return sum
  }
  function getSi2(arr1, avg1) {
    var g = 0
    var sum = 0
    var arr_len = arr1.length
    for (var w = 0; w < arr_len; w++) {
      var u = Math.pow(arr1[w] - avg1, 2)
      sum += u
    }
    return sum
  }
  function getSi3(arr1, arr2, avg1, avg2) {
    var g = 0
    var sum = 0
    var arr_len = arr1.length
    for (var w = 0; w < arr_len; w++) {
      var u = (arr1[w] - avg1) * (arr2[w] - avg2)
      sum += u
    }
    return sum
  }
  function getAvgerage(arr) {
    var initialValue = 0
    var sum = arr.reduce(
      (accumulator, currentValue) => accumulator + currentValue,
      initialValue
    );
    return sum / arr.length
  }

  function setTool(k) {

    if (k === 0) {
      rubber = false
      pen_type = 1
    }
    if (k === 1) {
      rubber = false
      pen_type = 0
    }

    if (k === 2) {
      rubber = true
    }
    var elt = document.querySelectorAll('.tools button')
    for (var e = 0; e < elt.length; e++) {
      elt[e].setAttribute('s', '0')
    }
    elt[k].setAttribute('s', 1)

  }

  function downloadblob(b, name) {

    const image = new File([b], name, { type: b.type })
    if (navigator.canShare && navigator.canShare({ files: [image] })) {
      navigator.share({
        files: [image]
      })
    }
    else {
      const a = document.createElement('a');
      document.body.appendChild(a);
      a.download = `${name}`;
      a.href = window.URL.createObjectURL(b);
      a.click()
      a.remove()
    }

  }

  function saveIntoSvg() {
    var serializer = new XMLSerializer();
    var svgString = serializer.serializeToString(document.querySelector("svg#canvas"));
    var blob = new Blob([svgString], { type: "image/svg+xml" });
    downloadblob(blob, gid('svg') + '.svg')
  }

  function saveIntoPng() {
    var w = document.querySelector("svg#canvas").clientWidth * Math.pow(dpr, 3)
    var h = document.querySelector("svg#canvas").clientHeight * Math.pow(dpr, 3)

    if (w * h > 4096 * 4096) {
      if (w > h) {
        h = h * (4096 / w)
        w = 4096
      }
      else {
        w = w * (4096 / h)
        h = 4096
      }
    }

    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "white";

    const svgString = new XMLSerializer().serializeToString(document.querySelector("svg#canvas"));
    const img = new Image();
    img.onload = function () {
      ctx.drawImage(img, 0, 0, w, h);
      canvas.toBlob(function (blob) {
        downloadblob(blob, gid('png') + '.png')
      }, "image/png");
    };
    img.src = "data:image/svg+xml;base64," + btoa(svgString);
  }
</script>

</html>